<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>ETL Pipeline Documentation – Enhancing Interoperability</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="bpmn_model.html">BPMN Model</a></li>
        <li><a href="etl_pipeline.html">ETL Pipeline</a></li>
        <li><a href="insights.html">Insights</a></li>
        <li><a href="team_contributions.html">Team Contributions</a></li>
        <li><a href="about.html">About</a></li>
      </ul>
      <a href="https://github.iu.edu/moukanda/test" class="github-btn" target="_blank">
        <img src="images/github_image.png" class="github-icon" alt="GitHub Logo">
        <span>View Project on GitHub</span>
      </a>
    </nav>
  </div>

  <!-- Main content wrapper -->
  <div class="content">
    <div class="content-inner">
      <section id="etl">
        <h1>ETL Pipeline Documentation</h1>
        <p>
          Our ETL pipeline extracts clinical data from an OpenEMR FHIR server, enriches it via SNOMED CT logic, and loads it into a Primary Care EHR server enforcing custom validation profiles. Implemented as modular Python scripts, it follows best practices for healthcare interoperability.
        </p>

        <!-- Coding Tasks Links -->
        <h2>Coding Tasks</h2>
        <ul>
          <li><a href="https://github.iu.edu/moukanda/test/blob/main/tasks/task_1.py" target="_blank">Task 1 – Parent SNOMED Condition</a></li>
          <li><a href="https://github.iu.edu/moukanda/test/blob/main/tasks/task_2.py" target="_blank">Task 2 – Child SNOMED Condition</a></li>
          <li><a href="https://github.iu.edu/moukanda/test/blob/main/tasks/task_3.py" target="_blank">Task 3 – Observation</a></li>
          <li><a href="https://github.iu.edu/moukanda/test/blob/main/tasks/task_4.py" target="_blank">Task 4 – Procedure</a></li>
          <li><a href="https://github.iu.edu/moukanda/test/blob/main/tasks/task_5.py" target="_blank">Task 5 – HL7 v2 Message Generation</a></li>
        </ul>

        <!-- Extraction -->
        <h2>Extraction</h2>
        <img src="images/extraction_image.png" alt="ETL Extraction" class="section-image">
        <p style="margin-top: 20px; margin-bottom: 20px;">Our extraction phase focused on retrieving clinical data from the OpenEMR FHIR server, specifically the Patient and Condition resources. We used RESTful API endpoints like <code>/Patient</code> and <code>/Condition?patient={id}</code> to gather the necessary information. Authentication was handled via OAuth 2.0 using a bearer token stored in a local file named <code>access_token.json</code>. Every request included this token in the Authorization header to gain secure access. We used query parameters like <code>birthdate=gt1900-01-01</code> and <code>name=Fernando</code> to filter specific patients.
        </p>
        <p style="margin-top: 20px; margin-bottom: 20px;">To handle edge cases, we implemented error checking by evaluating the status_code of each response. If a resource was missing or the request failed, the script skipped that entry and printed an error message. This helped us avoid halting the pipeline and ensured the system could recover gracefully from unexpected issues such as missing data or server errors.
        </p>
        <h3 style="font-size: 25px;">API Endpoints</h3>
        <pre><code>GET https://in-info-web20.luddy.indianapolis.iu.edu/apis/default/fhir/Patient
GET https://in-info-web20.luddy.indianapolis.iu.edu/apis/default/fhir/Condition?patient={id}</code></pre>

        <h3 style="font-size: 25px;">Authentication &amp; Authorization</h3>
        <pre><code class="language-python">def get_access_token():
    with open("data/access_token.json") as f:
        return json.load(f)["access_token"]

headers = {
    "Authorization": f"Bearer {get_access_token()}",
    "Content-Type": "application/json"
}</code></pre>

        <h3 style="font-size: 25px;">Error Handling</h3>
        <p>
          We skip any record whose API call returns a non-200 status, log the incident, and omit patients with no Condition resources.
        </p>

        <!-- Transformation -->
        <h2>Transformation</h2>
        <img src="images/transformation_image.png" alt="ETL Transformation" class="section-image">
        <p>
            Once the data was extracted, we began formatting and enriching it to match the custom profile requirements of the Primary Care FHIR server. We used the Hermes SNOMED CT API to enhance diagnosis data by finding either a parent <code>(constraint=>!{code})</code> or child <code>(constraint=<{code})</code> concept based on the original condition code. This SNOMED concept enrichment ensured semantic consistency and made our Condition resources suitable for posting. Additionally, we injected required FHIR elements like <code>"meta.profile", "deceasedBoolean", and "address.district"</code>.

        </p>
        
        <p style="margin-top: 20px; margin-bottom: 20px;">For each transformation, we parsed the raw FHIR JSON and either modified or added missing fields. We structured addresses to include city, district, and postal code. In Condition resources, we added severity, category, and bodySite fields using proper SNOMED values. All formatting was done in Python using native dictionaries and helper functions for clarity and reuse. These transformations ensured compatibility with the target server’s <code>$validate</code> conformance check.
        </p>
        <h3 style="font-size: 25px;">SNOMED CT Lookups</h3>
        <pre><code class="language-http"># Parent term
GET {SNOMED_HERMES_URL}/search?constraint=&gt;!{code}

# Child term
GET {SNOMED_HERMES_URL}/search?constraint=&lt;{code}</code></pre>

        <h3 style="font-size: 25px;">Field Injection &amp; Enrichment</h3>
        <ul>
          <li>Add <code>"deceasedBoolean": false</code> to all Patient resources.</li>
          <li>Inject <code>"district": "DefaultDistrict"</code> into missing address fields.</li>
          <li>Populate <code>severity</code>, <code>category</code>, and <code>bodySite</code> in Condition resources.</li>
          <li>Ensure each resource includes the correct <code>meta.profile</code> for validation.</li>
        </ul>

        <!-- Loading -->
        <h2>Loading</h2>
        <img src="images/loading_image.png" alt="ETL Loading" class="section-image">
        <p>
            After transformation, we loaded the processed resources into the Primary Care FHIR server via POST requests. Each request sent a JSON object representing a fully formed FHIR resource (Patient, Condition, etc.) to endpoints like <code>/Patient</code> and <code>/Condition</code>. These resources included the necessary metadata and profile declarations so they would pass server-side validation. The Python <code>requests.post()</code> method was used to upload data, and success was confirmed with <code>status_code == 201</code>.

        </p>
        <p style="margin-top: 20px; margin-bottom: 20px;">We also saved each final resource locally in a <code>data/directory</code> as <code>.json</code> files (e.g., <code>good_patient_1.json</code>) for use in the separate validation and HL7 messaging tasks. This modular approach separated transformation from validation, as instructed by our professor, and made debugging easier. After loading, each resource was available via the Primary Care server's FHIR interface for testing, visualization, and downstream workflows.
        </p>
        <pre><code class="language-python">response = requests.post(
    PRIMARY_PATIENT_URL,
    headers=headers,
    json=patient_payload
)
save_json(patient_payload, "good_condition_1.json")</code></pre>

        <h3 style="font-size: 25px;">FHIR Server Endpoints</h3>
        <pre><code>POST http://137.184.71.65:8080/fhir/Patient
POST http://137.184.71.65:8080/fhir/Condition</code></pre>

        <!-- Detailed Task Descriptions -->
        <h2>Task Details</h2>

        <h3>Task 1: Parent SNOMED Condition</h3>
        <p style=" margin-top: 20px; margin-bottom: 25px;">
          In Task 1, we extracted a patient’s Condition resource from OpenEMR and retrieved its SNOMED CT code. We queried Hermes with <code>?constraint=&gt;!{code}</code> to find a parent concept, then built a new Condition (with <code>meta.profile</code>, <code>clinicalStatus</code>, etc.) and saved it as <code>good_condition_1.json</code>.
        </p>
        <p style="margin-top: 20px; margin-bottom: 25px;">Once transformed, this new Condition was posted to the Primary Care FHIR server via a POST request. We also saved the resource as a <code>.json file (good_condition_1.json)</code> for later validation. During this task, we ensured that the associated Patient resource was already created and posted with correct fields. This task helped us learn how to enrich clinical data using SNOMED relationships and ensure that Condition resources match profile requirements before loading.
        </p>
        <pre><code class="language-python">url = f"{SNOMED_HERMES_URL}/search?constraint=>!{code}"
response = requests.get(url)
parent_code = response.json()[0]["conceptId"]
parent_term = response.json()[0]["preferredTerm"]</code></pre>

        <p>
          <strong>Challenge:</strong> Some codes had no parents.<br>
          <strong>Resolution:</strong> We used error handling to skip the condition if no parent was found, and printed a message to avoid crashing the ETL process.

        </p>

        <h3 style="margin-top: 50px; margin-bottom: 25px;">Task 2: Child SNOMED Condition</h3>
        <p style="margin-top: 20px; margin-bottom: 25px;"">
          For Task 2, we reused the same patient from Task 1 but created a new Condition using a child SNOMED CT term of the previously used concept. We used the Hermes Terminology Server again, but this time with the query <code>constraint=<{code{code}</code> to retrieve child terms. After selecting a valid child concept, we built a new FHIR Condition resource with similar structure and enriched fields as in Task 1, but now representing a more specific diagnosis.</p>
          <p style=" margin-top: 20px; margin-bottom: 25px;"> We then posted this child-level Condition to the Primary Care FHIR server and saved it as a separate .json file. This task demonstrated how SNOMED hierarchy can be used not just for broadening concepts (parent), but also for specifying more granular clinical meaning (child). It reinforced our understanding of how different levels of granularity are critical in clinical coding.</p>
        <pre><code class="language-python">url = f"{SNOMED_HERMES_URL}/search?constraint=<{code}"
response = requests.get(url)
child_code = response.json()[0]["conceptId"]
child_term = response.json()[0]["preferredTerm"]</code></pre>
        <p>
          <strong>Challenge:</strong> Some codes had no children.<br>
          <strong>Resolution:</strong> We looped through fallback codes if needed and skipped the step with a warning if no child was found
        </p>

        <h3 style=" margin-top: 50px; margin-bottom: 25px;">Task 3: Observation</h3>
        <p>
            In Task 3, we checked whether the selected patient had any existing Observation resource in OpenEMR, specifically for Blood Pressure. If none was found, we created a synthetic Observation using LOINC codes for systolic (<code>8480-6</code>) and diastolic (<code>8462-4</code>) blood pressure readings. We followed FHIR structure for Observation including status, category, code, component, and effectiveDateTime.

        </p>
        <p style="- margin-top: 20px; margin-bottom: 25px;">The completed Observation was posted to the Primary Care FHIR server using a POST request to the /Observation endpoint. This task taught us how to represent quantitative clinical measurements in FHIR and emphasized the importance of using standard codes like LOINC for observation data.
        </p>
        <pre><code class="language-python">bp_payload = {
  "resourceType":"Observation","status":"final",
  "category":[{"coding":[{"system":"http://terminology.hl7.org/CodeSystem/observation-category","code":"vital-signs"}]}],
  "code":{"coding":[{"system":"http://loinc.org","code":"85354-9","display":"Blood pressure panel"}]},
  "subject":{"reference":f"Patient/{patient_id}"},
  "component":[
    {"code":{"coding":[{"system":"http://loinc.org","code":"8480-6"}]},"valueQuantity":{"value":120,"unit":"mmHg"}},
    {"code":{"coding":[{"system":"http://loinc.org","code":"8462-4"}]},"valueQuantity":{"value":80,"unit":"mmHg"}}
  ]
}</code></pre>
        <p>
          <strong>Challenge:</strong> Observation structures are complex and required nesting of components.          <br>
          <strong>Resolution:</strong> We followed the FHIR examples closely and validated JSON structure before posting.
        </p>

        <h3 style=" margin-top: 50px; margin-bottom: 25px;">Task 4: Procedure</h3>
        <p>
            Task 4 required us to create a Procedure resource for the patient, simulating a clinical procedure such as an appendectomy. Since OpenEMR did not provide any procedures by default, we created one manually using a SNOMED CT code for (Appendectomy – SNOMED 80146002). We included essential fields such as status, code, subject, and performedDateTime and made sure the structure matched FHIR expectations.
        </p>
        <p style=" margin-top: 20px; margin-bottom: 25px;"> We posted the Procedure resource to the Primary Care FHIR server’s /Procedure endpoint. This task helped us understand how procedures differ from conditions or observations — in that they represent medical actions rather than diagnoses or measurements. It also reinforced the importance of accurate coding and timestamping in clinical documentation.
        </p>
        <pre><code class="language-python">procedure_payload = {
  "resourceType":"Procedure","status":"completed",
  "code":{"coding":[{"system":"http://snomed.info/sct","code":"80146002","display":"Appendectomy"}]},
  "subject":{"reference":f"Patient/{patient_id}"},
  "performedDateTime":"2020-04-20T14:30:00+00:00"
}</code></pre>
        <p>
          <strong>Challenge:</strong> The resource structure was unfamiliar at first.
          <br>
          <strong>Resolution:</strong> We used FHIR documentation and SNOMED browser to ensure proper structure and concept selection.

        </p>

        <h3 style=" margin-top: 50px; margin-bottom: 25px;">Task 5: HL7 v2 Message Generation</h3>
        <p>
            For Task 5, we demonstrated interoperability with legacy systems by generating a simplified <code>HL7 ADT^A01</code> message from our validated FHIR resources. We used the hl7apy library in Python to build standard HL7 segments like MSH, PID, PV1, and DG1. We pulled values from the previously saved good_patient_1.json and good_condition_1.json files to populate the message with real patient and condition data.


        </p>
        <p style=" margin-top: 20px; margin-bottom: 25px;">The HL7 message was then saved to adt_message.txt. This task highlighted how FHIR data can be mapped into legacy HL7 formats, which is essential in real-world hospital integrations. It also demonstrated that structured ETL processes allow smooth downstream transformation into multiple standards.
        </p>
        <pre><code class="language-python">from hl7apy.core import Message
msg = Message("ADT_A01")
msg.msh.msh_3 = "OpenEMR"
msg.msh.msh_9 = "ADT^A01"
msg.pid.pid_3 = patient_id
msg.pid.pid_5 = patient_name
# … PV1, DG1 …
with open("data/adt_message.txt","w") as f:
    f.write(msg.to_er7())</code></pre>
        <p>
          <strong>Challenge:</strong> HL7 segment rules and syntax were strict.
          <br>
          <strong>Resolution:</strong> We followed hl7apy documentation carefully and tested field values manually before writing to file.
        </p>
      </section>
    </div>
  </div>

  <!-- Footer -->
  <footer>
    <p>&copy; 2025 Enhancing Interoperability. All Rights Reserved.</p>
  </footer>
</body>
</html>
